#!/usr/bin/perl

# pragmas
use strict;
use Modern::Perl '2023';
use warnings FATAL => 'all';
use utf8;
use open qw(:std :utf8);
no feature qw(indirect);

# imports
use Math::Expression::Evaluator;
use Path::Class;
use Term::ReadLine;
use LWP::Simple;
use JSON;
use LLM::OpenAICompletion;
use Tools::GoogleSearch;


sub googleSearch($question) {
  return Tools::GoogleSearch->new()->search($question);
}



# Example usage
# my $question = "What is the capital city of Ireland?";
# my $answer = googleSearch($question);
# print "Answer: $answer\n";


my %tools = (
  'search' => {
    'description' => 'a search engine. useful for when you need to answer questions about current events. input should be a search query.',
    'execute' => \&googleSearch,
  },
  'calculator' => {
    'description' => 'Useful for getting the result of a math expression. The input to this tool should be a valid mathematical expression that could be executed by a simple calculator.',
    'execute' => sub {
      my ($input) = @_;
      return Math::Expression::Evaluator->new()->parse($input)->val();
    },
  },
);

# # Example usage
# my $tool = 'search';
# my $input = 'whats is a platypus?';
# my $result = $tools{$tool}->{'execute'}->($input);
# print "Result: $result\n";


my $script_path = File::Spec->rel2abs(__FILE__);
my ($volume, $script_directory, $file) = File::Spec->splitpath( $script_path );
my $prompt_file_path = File::Spec->catfile($script_directory, "prompt.txt");
my $promptTemplate = file($prompt_file_path)->slurp;
my $merge_file_path = File::Spec->catfile($script_directory, "merge.txt");
my $mergeTemplate = file($merge_file_path)->slurp;

# Example usage
# print "Prompt Template:\n$promptTemplate\n";
# print "Merge Template:\n$mergeTemplate\n";

sub completePrompt( $prompt ) {
  my $llm = LLM::OpenAICompletion->new();
  return $llm->completion_response($prompt);
}

# Example usage
# my $prompt = "What is a platypus?";
# my $result = completePrompt($prompt);

sub trim {
  my ($string) = @_;
  $string =~ s/^\s+|\s+$//g;
  return $string;
}

sub answerQuestion {
  my ($question) = @_;

  # Construct the prompt, replacing placeholders with question and tools information
  my $prompt = $promptTemplate;
  $prompt =~ s/\$\{question\}/$question/g;
  $prompt =~ s/\$\{tools\}/join("\n", map {"$_: $tools{$_}->{'description'}"} keys %tools)/e;

  # Allow the model to iterate until a final answer is found
  while (1) {
    my $response = completePrompt($prompt);

    # Add the response to the prompt
    $prompt .= $response;

    my ($action) = $response =~ /Action: (.*)/;
    if ($action) {
      # Execute the action specified by the model
      my ($actionInput) = $response =~ /Action Input: "?(.*)"?/;
      my $result = $tools{trim($action)}->{'execute'}->($actionInput);
      $prompt .= "Observation: $result\n";
    } else {
      my ($finalAnswer) = $response =~ /Final Answer: (.*)/;
      return $finalAnswer;
    }
  }
}

sub mergeHistory {
  my ($question, $history) = @_;

  my $prompt = $mergeTemplate;
  $prompt =~ s/\$\{question\}/$question/g;
  $prompt =~ s/\$\{history\}/$history/g;

  return completePrompt($prompt);
}

my $history = "";
my $term = Term::ReadLine->new("How can I help? ");

while (1) {
  my $question = $term->readline("How can I help? ");
  if (length($history) > 0) {
    $question = mergeHistory($question, $history);
  }
  my $answer = answerQuestion($question);
  print "$answer\n";
  $history .= "Q:$question\nA:$answer\n";
}
