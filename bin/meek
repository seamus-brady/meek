#!/usr/bin/perl

# Copyright (c) 2023. seamus@meek.ai, Corvideon Limited.
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# pragmas
use strict;
use Modern::Perl '2023';
use warnings FATAL => 'all';
use utf8;
use open qw(:std :utf8);
no feature qw(indirect);

# imports
use Path::Class;
use Term::ReadLine;
use Try::Tiny;
use LLM::OpenAICompletion;
use Tools::Search::BingSearch;
use Tools::Calculator;

sub searchTool($input) {
  return Tools::Search::BingSearch->new()->search($input);
}

sub calcTool($input) {
  return Tools::Calculator->calculate($input);
}

sub tool_config {
  my $input = shift;
  my %tools = (
    'search'     => {
      'description' => qq(
      A search engine. useful for when you need to answer questions about current events.
      Input should be a search query.'),
      'execute'     => \&searchTool,
    },
    'calculator' => {
      'description' => qq(
      Useful for getting the result of a math expression.
      The input to this tool should be a valid mathematical expression that could be executed by a simple calculator.),
      'execute'     => \&calcTool,
    },
  );
  return %tools;
}


my %tools = tool_config();

my $script_path = File::Spec->rel2abs(__FILE__);
my ($volume, $script_directory, $file) = File::Spec->splitpath($script_path);
my $prompt_file_path = File::Spec->catfile($script_directory, "prompt.txt");
my $promptTemplate = file($prompt_file_path)->slurp;
my $merge_file_path = File::Spec->catfile($script_directory, "merge.txt");
my $mergeTemplate = file($merge_file_path)->slurp;


sub completePrompt($prompt) {
  my $llm = LLM::OpenAICompletion->new();
  return $llm->completion_response($prompt);
}


sub trim {
  my ($string) = @_;
  $string =~ s/^\s+|\s+$//g;
  return $string;
}

sub answerQuestion {
  my ($question) = @_;

  # Construct the prompt, replacing placeholders with question and tools information
  my $prompt = $promptTemplate;
  $prompt =~ s/\$\{question\}/$question/g;
  $prompt =~ s/\$\{tools\}/join("\n", map {"$_: $tools{$_}->{'description'}"} keys %tools)/e;

  # Allow the model to iterate until a final answer is found
  while (1) {
    my $response = completePrompt($prompt);

    # Add the response to the prompt
    $prompt .= $response;

    my ($action) = $response =~ /Action: (.*)/;
    if ($action) {
      # Execute the action specified by the model
      my ($actionInput) = $response =~ /Action Input: "?(.*)"?/;
      my $result = $tools{trim($action)}->{'execute'}->($actionInput);
      $prompt .= "Observation: $result\n";
    }
    else {
      my ($finalAnswer) = $response =~ /Final Answer: (.*)/;
      return $finalAnswer;
    }
  }
}

sub mergeHistory {
  my ($question, $history) = @_;

  my $prompt = $mergeTemplate;
  $prompt =~ s/\$\{question\}/$question/g;
  $prompt =~ s/\$\{history\}/$history/g;

  return completePrompt($prompt);
}

my $history = "";
my $term = Term::ReadLine->new("How can I help? ");

while (1) {
  my $question = $term->readline("How can I help? ");
  if (length($history) > 0) {
    $question = mergeHistory($question, $history);
  }
  try {
    my $answer = answerQuestion($question);
    print "$answer\n";
    $history .= "Q:$question\nA:$answer\n";
  }  catch { warn "$_" }
}
